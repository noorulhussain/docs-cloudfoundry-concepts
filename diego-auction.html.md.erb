---
title: Diego Auctioneer
---

The Diego Auctioneer distributes Tasks and Long Running Processes (LRPs) to [Cells](./diego-components.html#cell-components). Diego Auction replaces the [Cloud Controller DEA placement algorithm](./architecture/cloud-controller.html#dea-placement), which performed this function in the pre-Diego Cloud Foundry architecture.
 
The Diego Auctioneer initiates an auction, queries cells, prioritizes work to be auctioned, and distributes tasks and LRPs to cells.

## <a id='initiate'></a>Initiate an Auction

An [Auctioneer](./diego-components.html#auctioneer) initiates an auction when it receives a request to allocate a batch of tasks and LRPs from either of the following:

- A Cell [Receptor](./diego-components.html#receptor), in response to a request from the Cloud Controller

- A [Converger](./diego-components.html#converger), in response to a discrepancy between the `DesiredLRPs` and `ActualLRPs` as represented in the [Bulletin Board System](./diego-components.html#bbs) (BBS)

<p class="note"><strong>Note</strong>: The Auctioneer maintains a lock in the BBS that restricts auctions to one Auctioneer at a time.</p>

## <a id='fetch-info'></a>Query the Cells

The Auctioneer queries each Cell [Rep](./diego-components.html#rep) for the following information:

- Available capacity
- RootFSProviders
- the number `ActiveLRPs`

## <a id='prioritizing'></a>Prioritize the Batch of Tasks and LRPs

The Auctioneer prioritizes each batch of Tasks and LRPs.

The Diego Auctioneer sorts the batch of LRPs to allocate into priority groups based on their global indices. Each LRP has an index for its type, which is unique across a deployment. Within each priority group, work is sorted in order of decreasing memory demand so that larger units of work are placed first.

to avoid incorrectly fill the Cells with small units of work before attempting to place large units of work. As a result, these large units could fail to place even if there is sufficient capacity in the cluster. 

* The Auctioneer could incorrectly prioritize large units of work over small units of work. As a result, each Cell could be filled with a single large app, preventing smaller apps from having any instances running.

For example, suppose a batch contains the following 5 LRPS:

<table border='1' class='nice'>
	<tr>
		<th>LRP type</th>
		<th>LRP index</th>
	</tr>
		<td>type 1</td>
		<td>0</td>
	<tr>
		<td>type 1</td>
		<td>1</td>
	</tr>
		<td>type 1</td>
		<td>2</td>
	<tr>
		<td>type 2</td>
		<td>0</td>
	</tr>
	<tr>
		<td>type 2</td>
		<td>1</td>
	</tr>
</table>

The Auctioneer would allocate the LRPs in the following order:

* Type 1/ Index 0
* Type 2/ Index 0
* Type 1/ Index 1
* Type 2/ Index 1
* Type 1/ Index 2

This sorting by index ensures that LRPs of each type are placed before all of the LRPs of any type are, preventing both large and small LRPs from dominating the allocation process.

## <a id='allocating'></a>Allocate Work

For each Tasks and LRP, the Auctioneer selects a Cell using the following process: 

1. Filter for cells with appropriate `RootFSProviders` and sufficient resources

1. Optimizes for the following, in decreasing priority:
	1. An even distribution of `ActualLRP` instances of a given `DesiredLRP` across Availability Zones
	1. An even distribution of `ActualLRP` instances of a given `DesiredLRP` across Cells
	1. An even distribution of memory, disk, and container usage across Cells

1. After calculating the distribution of Tasks and LRPs to Cells, the Auctioneer submits requests to the Cells to execute their allotted work.

Any work that could not be allocated is carried over into the next batch.

If a Cell responds by saying the work can not be performed, the Auctioneer carries the failed work over into the next batch.

If a Cell fails to respond, for example if a connection times out, the Auctioneer does *not* carry the work over into the next batch. In this case the Auctioneer defers to the Converger to figure out what to do.

Any work carried over into the next batch is merged with work that came in during the previous auction, and the loop is repeated.
